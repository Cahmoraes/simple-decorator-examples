(self.webpackChunksimple_decorators=self.webpackChunksimple_decorators||[]).push([[971,565],{68:(n,o,e)=>{"use strict";e.d(o,{B:()=>t});var t=function(n){var o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return function(e,t){var a=null;return Object.defineProperty(e,t,{get:function(){return a||o?!a&&o&&(a=document.querySelectorAll(n)):a=document.querySelector(n),a}})}}},971:(n,o,e)=>{"use strict";e.r(o),e.d(o,{default:()=>u});var t=e(610),a=e(991),s=e(140),r=e(18),d=e(68),c=e(565),i=e.n(c),u=function(){function n(){var o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:document.getElementById("root");(0,t.Z)(this,n),this._root=o,s.Z.property(this,{_button_1:(0,d.B)("#button_1"),_output_1:(0,d.B)("#output_1")}),this._config={title:"Method Decorator",button_1:"button_1",output_1:"output_1"}}return(0,a.Z)(n,[{key:"render",value:function(){this._root.insertAdjacentHTML("beforeend",i()(this._config))}},{key:"addEventListener",value:function(){this._button_1.addEventListener("click",this.loadContent.bind(this))}},{key:"loadContent",value:function(){this._output_1.textContent+="Executou\n"}},{key:"init",value:function(){return this.render(),this.addEventListener(),this}}]),n}();s.Z.method(u,{loadContent:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:200,o=0;return function(e,t,a){o&&clearTimeout(o),o=setTimeout((function(){return o=0,e.apply(void 0,(0,r.Z)(a))}),n)}}(500)})},565:n=>{function o(){return`<div class="content">\n  <h2 class="subtitle">${this.title}</h2>\n  <article id="observable">\n    <div class="container-fluid">\n      <div class="grid-12">\n        <section class="row">\n          <div class="grid-12 description">\n            <h3>Sintaxe</h3>\n            <pre class="code">\n              sd.method(clazz, handler)\n            </pre>\n            <p>\n              O Decorator Pattern é um mecanismo que permite estender o comportamento de um objeto em tempo de execução, adicionando novas funcionalidades sem ter que criar uma nova classe ou, no caso do JavaScript, função construtora.</p>\n            <p>\n              O decorador de méthodo é uma função aplicada após a declaração da classe.<br>\n              Ela obtém a função construtora da classe e um objeto contendo o nome de cada método que terá seu comportamento estendido por um ou mais decorators.\n            </p>\n            <h3>Parâmetros</h3>\n            <p>\n              <strong>clazz:</strong> Função construtora da classe que contém os métodos que serão decorados.\n            </p>\n            <p>\n              <strong>handler:</strong> Objeto de configurações que contém os métodos a serem decorados, seguidas por seus respectivos decorators. No caso de mais de um decorator, os mesmos devem ser passados dentro de um array.\n            </p>\n            <pre class="code">\n              class Control {\n                <span class="tab_1">constructor () {</span>\n                <span class="tab_2">this._output_1 = document.querySelector('#output_1')</span>\n                <span class="tab_2">this._button_1 = document.querySelector('#button_1')</span>\n                <span class="tab_1">}</span>\n                <br>\n                <span class="tab_1">addEventListener () {</span>\n                <span class="tab_2">this._button_1.addEventListener('click', this.loadContent.bind(this))</span>\n                <span class="tab_1">}</span>\n                <br>\n                <span class="tab_1">loadContent () {</span>\n                <span class="tab_2">this._output_1.textContent += 'Executou\n'</span>\n                <span class="tab_1">}</span>\n                <br>\n                <span class="tab_1">init () {</span>\n                <span class="tab_2">this.addEventListener()</span>\n                <span class="tab_1">}</span>\n              }\n              <br>\n              sd.method(\n                <span class="tab_1">Control,</span>\n                <span class="tab_1">{</span>\n                <span class="tab_2">loadContent: debounceTime(200)</span>\n                <span class="tab_1">}</span>\n              )\n            </pre>\n          </div>\n        </section>\n        <section class="row examples">\n          <div class="grid-12">\n            <button id="${this.button_1}">Carregar</button>\n          </div>\n          <div class="grid-12 MT10">\n            <p id="${this.output_1}"></p>\n          </div>\n        </section>\n        <section class="row">\n          <div class="grid-12 description">\n            <h3>Anatomia do decorator de método</h3>\n            <p>\n              Os decorators de método, são funções que recebem três parâmetros: "method", "property", "args".\n              Sendo <strong>method</strong> o método da classe com seu this associado ao próprio objeto que invocará o método, <strong>property</strong> a propriedade que será criada e decorada (no caso o nome do método) e args, os parâmetros que a método recebe via argumentos na chamada.\n            </p>\n            <p>É possível receber parâmetros adicionais para auxiliar na configuração do decorator, por meio de Higher-Order-Function (uma função que recebe ou rotorna outra função).</p>\n            <p>\n              O decorator abaixo, conhecido como domInject, é uma Higher-Order-Function, recebe os parâmetros de configuração do decorator: <strong>selector</strong> e <strong>list</strong> e retorna uma nova função que será chamada pelo método sd.property onde serão passados os argumentos necessários para a construção do decorator:\n            </p>\n            <ul>\n              <li>\n                <strong>method</strong>: o método original da classe, pronto para ser executado.\n              </li>\n              <li>\n                <strong>property</strong>: nome do método que está sendo decorado.\n              </li>\n              <li>\n                <strong>args</strong>: array de todos os argumentos recebido na chamada do método.\n              </li>\n            </ul>\n            <p>\n              O papel do debounceTime é adiar a chama de uma execução para um determinado tempo em milissegundos. O debounceTime cancelará todas as chamadas consecutivas e executará o método original após o intervalo pré-definido. Essa técnica protege que uma quantidade de requisões indevidas sejam realizadas consecutivamente.\n            </p>\n            <pre class="code">\n              const debounceTime = (milliseconds = 200) => {\n                <span class="tab_1">let timer = 0</span>\n                <span class="tab_1">return (method, property, args) => {</span>\n                <span class="tab_2">if (timer) clearTimeout(timer)</span>\n                <span class="tab_2">timer = setTimeout(() => {</span>\n                <span class="tab_3">timer = 0</span>\n                <span class="tab_3">return method(...args)</span>\n                <span class="tab_2">}, milliseconds)</span>\n                <span class="tab_1">}</span>\n              }\n            </pre>\n          </div>\n        </section>\n      </div>\n    </div>\n  </article>\n</div>`}n.exports=function(n){return o.call(n,n)}}}]);