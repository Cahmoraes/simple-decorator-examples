(self.webpackChunksimple_decorators=self.webpackChunksimple_decorators||[]).push([[565],{565:a=>{function n(){return`<div class="content">\n  <h2 class="subtitle">${this.title}</h2>\n  <article id="observable">\n    <div class="container-fluid">\n      <div class="grid-12">\n        <section class="row">\n          <div class="grid-12 description">\n            <h3>Sintaxe</h3>\n            <pre class="code">\n              sd.method(clazz, handler)\n            </pre>\n            <p>\n              O Decorator Pattern é um mecanismo que permite estender o comportamento de um objeto em tempo de execução, adicionando novas funcionalidades sem ter que criar uma nova classe ou, no caso do JavaScript, função construtora.</p>\n            <p>\n              O decorador de méthodo é uma função aplicada após a declaração da classe.<br>\n              Ela obtém a função construtora da classe e um objeto contendo o nome de cada método que terá seu comportamento estendido por um ou mais decorators.\n            </p>\n            <h3>Parâmetros</h3>\n            <p>\n              <strong>clazz:</strong> Função construtora da classe que contém os métodos que serão decorados.\n            </p>\n            <p>\n              <strong>handler:</strong> Objeto de configurações que contém os métodos a serem decorados, seguidas por seus respectivos decorators. No caso de mais de um decorator, os mesmos devem ser passados dentro de um array.\n            </p>\n            <pre class="code">\n              class Control {\n                <span class="tab_1">constructor () {</span>\n                <span class="tab_2">this._output_1 = document.querySelector('#output_1')</span>\n                <span class="tab_2">this._button_1 = document.querySelector('#button_1')</span>\n                <span class="tab_1">}</span>\n                <br>\n                <span class="tab_1">addEventListener () {</span>\n                <span class="tab_2">this._button_1.addEventListener('click', this.loadContent.bind(this))</span>\n                <span class="tab_1">}</span>\n                <br>\n                <span class="tab_1">loadContent () {</span>\n                <span class="tab_2">this._output_1.textContent += 'Executou\n'</span>\n                <span class="tab_1">}</span>\n                <br>\n                <span class="tab_1">init () {</span>\n                <span class="tab_2">this.addEventListener()</span>\n                <span class="tab_1">}</span>\n              }\n              <br>\n              sd.method(\n                <span class="tab_1">Control,</span>\n                <span class="tab_1">{</span>\n                <span class="tab_2">loadContent: debounceTime(200)</span>\n                <span class="tab_1">}</span>\n              )\n            </pre>\n          </div>\n        </section>\n        <section class="row examples">\n          <div class="grid-12">\n            <button id="${this.button_1}">Carregar</button>\n          </div>\n          <div class="grid-12 MT10">\n            <p id="${this.output_1}"></p>\n          </div>\n        </section>\n        <section class="row">\n          <div class="grid-12 description">\n            <h3>Anatomia do decorator de método</h3>\n            <p>\n              Os decorators de método, são funções que recebem três parâmetros: "method", "property", "args".\n              Sendo <strong>method</strong> o método da classe com seu this associado ao próprio objeto que invocará o método, <strong>property</strong> a propriedade que será criada e decorada (no caso o nome do método) e args, os parâmetros que a método recebe via argumentos na chamada.\n            </p>\n            <p>É possível receber parâmetros adicionais para auxiliar na configuração do decorator, por meio de Higher-Order-Function (uma função que recebe ou rotorna outra função).</p>\n            <p>\n              O decorator abaixo, conhecido como domInject, é uma Higher-Order-Function, recebe os parâmetros de configuração do decorator: <strong>selector</strong> e <strong>list</strong> e retorna uma nova função que será chamada pelo método sd.property onde serão passados os argumentos necessários para a construção do decorator:\n            </p>\n            <ul>\n              <li>\n                <strong>method</strong>: o método original da classe, pronto para ser executado.\n              </li>\n              <li>\n                <strong>property</strong>: nome do método que está sendo decorado.\n              </li>\n              <li>\n                <strong>args</strong>: array de todos os argumentos recebido na chamada do método.\n              </li>\n            </ul>\n            <p>\n              O papel do debounceTime é adiar a chama de uma execução para um determinado tempo em milissegundos. O debounceTime cancelará todas as chamadas consecutivas e executará o método original após o intervalo pré-definido. Essa técnica protege que uma quantidade de requisões indevidas sejam realizadas consecutivamente.\n            </p>\n            <pre class="code">\n              const debounceTime = (milliseconds = 200) => {\n                <span class="tab_1">let timer = 0</span>\n                <span class="tab_1">return (method, property, args) => {</span>\n                <span class="tab_2">if (timer) clearTimeout(timer)</span>\n                <span class="tab_2">timer = setTimeout(() => {</span>\n                <span class="tab_3">timer = 0</span>\n                <span class="tab_3">return method(...args)</span>\n                <span class="tab_2">}, milliseconds)</span>\n                <span class="tab_1">}</span>\n              }\n            </pre>\n          </div>\n        </section>\n      </div>\n    </div>\n  </article>\n</div>`}a.exports=function(a){return n.call(a,a)}}}]);