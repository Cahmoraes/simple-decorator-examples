(self.webpackChunksimple_decorators=self.webpackChunksimple_decorators||[]).push([[242,434],{68:(e,n,s)=>{"use strict";s.d(n,{B:()=>a});var a=function(e){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return function(s,a){var t=null;return Object.defineProperty(s,a,{get:function(){return t||n?!t&&n&&(t=document.querySelectorAll(e)):t=document.querySelector(e),t}})}}},242:(e,n,s)=>{"use strict";s.r(n),s.d(n,{default:()=>p});var a=s(610),t=s(991),o=s(432),r=s(434),i=s.n(r),d=s(140),c=s(68),p=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:document.getElementById("root");(0,a.Z)(this,e),this._root=n,d.Z.property(this,{_input_1:(0,c.B)("#input_1"),_output_1:(0,c.B)("#output_1"),_output_2:(0,c.B)("#output_2")}),this._label_1="Dados de entrada",this._label_2="Dados de saída",this._label_3="prevValue:",this._label_4="newValue:",this._$obs_1=null,this._config={title:"Property Decorator",label_1:this._label_1,label_2:this._label_2,label_3:this._label_3,label_4:this._label_4,input_1:"input_1",output_1:"output_1",output_2:"output_2"}}return(0,t.Z)(e,[{key:"createObservable",value:function(){var e=this;this._$obs_1=o.Z.observable("",(function(n,s,a){e._output_1.textContent=n,e._output_2.textContent=s,a()}))}},{key:"addEventListenerInputs",value:function(){var e=this;this._input_1.addEventListener("input",(function(n){var s=n.target.value;e._$obs_1(s)}))}},{key:"render",value:function(){this._root.insertAdjacentHTML("beforeend",i()(this._config))}},{key:"init",value:function(){return this.render(),this.createObservable(),this.addEventListenerInputs(),this}}]),e}()},434:e=>{function n(){return`<div class="content">\n  <h2 class="subtitle">${this.title}</h2>\n  <article id="middleware">\n    <div class="container-fluid">\n      <div class="grid-12">\n        <section class="row">\n          <div class="grid-12 description">\n            <h3>Sintaxe</h3>\n            <pre class="code">\n              sd.property(this, handler)\n            </pre>\n            <p>\n              O Decorator Pattern é um mecanismo que permite estender o comportamento de um objeto em tempo de execução, adicionando novas funcionalidades sem ter que criar uma nova classe ou, no caso do JavaScript, função construtora.\n            </p>\n            <p>\n              O decorador de propriedade é uma função aplicada na declaração de propriedades em nossas classes, dentro do <strong>constructor</strong>.<br>\n              Ela obtém a referência do objeto da classe <strong>(this)</strong> e um objeto contendo o nome de cada propriedade que será criada e adicionada à classe e que terá seu comportamento estendido por um ou mais decorators.\n            </p>\n            <h3>Parâmetros</h3>\n            <p><strong>this:</strong> Objeto this associado à classe.</p>\n            <p><strong>handler:</strong> Objeto de configurações que contém as propriedades a serem decoradas, seguidas por seus respectivos decorators. No caso de mais de um decorator, os mesmos devem ser passados dentro de um array.</p>\n            <pre class="code">\n              class FormExample {\n              <span class="tab_1">constructor() {</span>\n              <span class="tab_2">sd.property(</span>\n              <span class="tab_3">this,</span>\n              <span class="tab_3">{</span>\n              <span class="tab_4">_button_1: domInject('#button_1'),</span>\n              <span class="tab_4">_inicialValue: domInject('#inicialValue'),</span>\n              <span class="tab_4">_prevValue: domInject('#prevValue')</span>\n              <span class="tab_3">}</span>\n              <span class="tab_2">)</span>\n              <span class="tab_1">}</span>\n              <span class="tab_1">...</span>\n              }\n            </pre>\n          </div>\n        </section>\n        <section class="row">\n          <div class="grid-12">\n            <div class="form-group">\n              <label for="input_1">${this.label_1}:</label>\n              <input type="text" id="${this.input_1}" name="${this.input_1}">\n            </div>\n            <div class="form-group">\n              <p>${this.label_2}:</p>\n              <div class="row">\n                <div class="grid-6">\n                  <span>${this.label_3}</span>\n                  <div class="row">\n                    <p class="grid-6 word-break" id="${this.output_1}"></p>\n                  </div>\n                </div>\n                <div class="grid-6">\n                  <span>${this.label_4}</span>\n                  <div class="row">\n                    <p class="grid-6 word-break" id="${this.output_2}"></p>\n                  </div>\n                </div>\n              </div>\n            </div>\n        </section>\n        <section class="row">\n          <div class="grid-12 description">\n            <h3>Anatomia do decorator de propriedade</h3>\n            <p>\n              Os decorators de propriedade, são funções que recebem dois parâmetros: "thisArg e property".\n              Sendo <strong>thisArg</strong> a referência da instância do objeto da classe, e <strong>property</strong> a propriedade que será criada e decorada.\n            </p>\n            <p>É possível receber parâmetros adicionais para auxiliar na configuração do decorator, por meio de Higher-Order-Function (uma função que recebe ou rotorna outra função).</p>\n            <p>\n              O decorator abaixo, conhecido como domInject, é uma Higher-Order-Function, recebe os parâmetros de configuração do decorator: <strong>selector</strong> e <strong>list</strong> e retorna uma nova função que será chamada pelo método sd.property onde serão passados os argumentos necessários para a construção do decorator:\n            </p>\n            <ul>\n              <li>\n                <strong>thisArg</strong>: this associado à respectiva classe onde a propriedade será criada\n              </li>\n              <li>\n                <strong>property</strong>: nome da propriedade que será criada e receberá o decorator.\n              </li>\n            </ul>\n            <p>\n              O papel do domInject é receber um seletor CSS, adicionar a nova propriedade na classe e configurar decriptor da propriedade. E neste caso, estamos dizendo que quando a propriedade for acessada para leitura: <strong>objInstance.property</strong>, será retornado uma referência para um elemento no DOM ou null caso não exista.\n            </p>\n            <pre class="code">\n              const domInject = (selector, list = false) => (thisArg, property) => {\n                <span class="tab_1">let element = null</span>\n                <span class="tab_2">return Object.defineProperty(thisArg, property, {</span>\n                <span class="tab_3">get () {</span>\n                <span class="tab_4">if (!element && !list) element = document.querySelector(selector)</span>\n                <span class="tab_4">else if (!element && list) element = document.querySelectorAll(selector)</span>\n                <span class="tab_3">return element</span>\n                <span class="tab_2">}</span>\n                <span class="tab_1">})</span>\n              }\n            </pre>\n          </div>\n        </section>\n      </div>\n    </div>\n</div>\n</article>\n</div>`}e.exports=function(e){return n.call(e,e)}}}]);