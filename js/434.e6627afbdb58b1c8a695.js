(self.webpackChunksimple_decorators=self.webpackChunksimple_decorators||[]).push([[434],{434:e=>{function s(){return`<div class="content">\n  <h2 class="subtitle">${this.title}</h2>\n  <article id="middleware">\n    <div class="container-fluid">\n      <div class="grid-12">\n        <section class="row">\n          <div class="grid-12 description">\n            <h3>Sintaxe</h3>\n            <pre class="code">\n              sd.property(this, handler)\n            </pre>\n            <p>\n              O Decorator Pattern é um mecanismo que permite estender o comportamento de um objeto em tempo de execução, adicionando novas funcionalidades sem ter que criar uma nova classe ou, no caso do JavaScript, função construtora.\n            </p>\n            <p>\n              O decorador de propriedade é uma função aplicada na declaração de propriedades em nossas classes, dentro do <strong>constructor</strong>.<br>\n              Ela obtém a referência do objeto da classe <strong>(this)</strong> e um objeto contendo o nome de cada propriedade que será criada e adicionada à classe e que terá seu comportamento estendido por um ou mais decorators.\n            </p>\n            <h3>Parâmetros</h3>\n            <p><strong>this:</strong> Objeto this associado à classe.</p>\n            <p><strong>handler:</strong> Objeto de configurações que contém as propriedades a serem decoradas, seguidas por seus respectivos decorators. No caso de mais de um decorator, os mesmos devem ser passados dentro de um array.</p>\n            <pre class="code">\n              class FormExample {\n              <span class="tab_1">constructor() {</span>\n              <span class="tab_2">sd.property(</span>\n              <span class="tab_3">this,</span>\n              <span class="tab_3">{</span>\n              <span class="tab_4">_button_1: domInject('#button_1'),</span>\n              <span class="tab_4">_inicialValue: domInject('#inicialValue'),</span>\n              <span class="tab_4">_prevValue: domInject('#prevValue')</span>\n              <span class="tab_3">}</span>\n              <span class="tab_2">)</span>\n              <span class="tab_1">}</span>\n              <span class="tab_1">...</span>\n              }\n            </pre>\n          </div>\n        </section>\n        <section class="row">\n          <div class="grid-12">\n            <div class="form-group">\n              <label for="input_1">${this.label_1}:</label>\n              <input type="text" id="${this.input_1}" name="${this.input_1}">\n            </div>\n            <div class="form-group">\n              <p>${this.label_2}:</p>\n              <div class="row">\n                <div class="grid-6">\n                  <span>${this.label_3}</span>\n                  <div class="row">\n                    <p class="grid-6 word-break" id="${this.output_1}"></p>\n                  </div>\n                </div>\n                <div class="grid-6">\n                  <span>${this.label_4}</span>\n                  <div class="row">\n                    <p class="grid-6 word-break" id="${this.output_2}"></p>\n                  </div>\n                </div>\n              </div>\n            </div>\n        </section>\n        <section class="row">\n          <div class="grid-12 description">\n            <h3>Anatomia do decorator de propriedade</h3>\n            <p>\n              Os decorators de propriedade, são funções que recebem dois parâmetros: "thisArg e property".\n              Sendo <strong>thisArg</strong> a referência da instância do objeto da classe, e <strong>property</strong> a propriedade que será criada e decorada.\n            </p>\n            <p>É possível receber parâmetros adicionais para auxiliar na configuração do decorator, por meio de Higher-Order-Function (uma função que recebe ou rotorna outra função).</p>\n            <p>\n              O decorator abaixo, conhecido como domInject, é uma Higher-Order-Function, recebe os parâmetros de configuração do decorator: <strong>selector</strong> e <strong>list</strong> e retorna uma nova função que será chamada pelo método sd.property onde serão passados os argumentos necessários para a construção do decorator:\n            </p>\n            <ul>\n              <li>\n                <strong>thisArg</strong>: this associado à respectiva classe onde a propriedade será criada\n              </li>\n              <li>\n                <strong>property</strong>: nome da propriedade que será criada e receberá o decorator.\n              </li>\n            </ul>\n            <p>\n              O papel do domInject é receber um seletor CSS, adicionar a nova propriedade na classe e configurar decriptor da propriedade. E neste caso, estamos dizendo que quando a propriedade for acessada para leitura: <strong>objInstance.property</strong>, será retornado uma referência para um elemento no DOM ou null caso não exista.\n            </p>\n            <pre class="code">\n              const domInject = (selector, list = false) => (thisArg, property) => {\n                <span class="tab_1">let element = null</span>\n                <span class="tab_2">return Object.defineProperty(thisArg, property, {</span>\n                <span class="tab_3">get () {</span>\n                <span class="tab_4">if (!element && !list) element = document.querySelector(selector)</span>\n                <span class="tab_4">else if (!element && list) element = document.querySelectorAll(selector)</span>\n                <span class="tab_3">return element</span>\n                <span class="tab_2">}</span>\n                <span class="tab_1">})</span>\n              }\n            </pre>\n          </div>\n        </section>\n      </div>\n    </div>\n</div>\n</article>\n</div>`}e.exports=function(e){return s.call(e,e)}}}]);